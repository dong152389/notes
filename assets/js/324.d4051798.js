(window.webpackJsonp=window.webpackJsonp||[]).push([[324],{1492:function(t,e,r){"use strict";r.r(e);var s=r(26),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),r("p",[t._v("在应用开发中，特别是web工程开发，通常都是并发编程，不是多进程就是多线程。这种场景下极易出现线程并发性安全问题，此时不得不使用锁来解决问题。在多线程高并发场景下，为了保证资源的线程安全问题，jdk为我们提供了synchronized关键字和ReentrantLock可重入锁，但是它们只能保证一个工程内的线程安全。在分布式集群、微服务、云原生横行的当下，如何保证不同进程、不同服务、不同机器的线程安全问题，jdk并没有给我们提供既有的解决方案。此时，我们就必须借助于相关技术手动实现了。目前主流的实现有以下方式：")]),t._v(" "),r("ol",[r("li",[t._v("基于mysql关系型实现")]),t._v(" "),r("li",[t._v("基于redis非关系型数据实现")]),t._v(" "),r("li",[t._v("基于zookeeper/etcd实现")])]),t._v(" "),r("p",[r("RouterLink",{attrs:{to:"/distributed-lock/"}},[r("strong",[t._v("开始学习")])])],1)])}),[],!1,null,null,null);e.default=n.exports}}]);