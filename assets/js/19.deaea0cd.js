(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{1589:function(t,s,a){"use strict";a.r(s);var e=a(26),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"redis-事务-锁机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务-锁机制"}},[t._v("#")]),t._v(" Redis 事务—锁机制")]),t._v(" "),e("h2",{attrs:{id:"redis-的事务定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-的事务定义"}},[t._v("#")]),t._v(" Redis 的事务定义")]),t._v(" "),e("p",[e("img",{attrs:{src:a(945),alt:"image-20221110101133247"}})]),t._v(" "),e("p",[t._v("Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。")]),t._v(" "),e("p",[t._v("Redis 事务的主要作用就是"),e("font",{attrs:{color:"red"}},[t._v("串联多个命令")]),t._v("防止别的命令插队。")],1),t._v(" "),e("h2",{attrs:{id:"multi、exec、discard"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#multi、exec、discard"}},[t._v("#")]),t._v(" Multi、Exec、discard")]),t._v(" "),e("p",[t._v("从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。")]),t._v(" "),e("p",[t._v("组队的过程中可以通过discard来放弃组队。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(946),alt:"image-20221110102258572"}})]),t._v(" "),e("p",[t._v("组队成功，提交成功。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(947),alt:""}})]),t._v(" "),e("p",[t._v("组队阶段报错，提交失败")]),t._v(" "),e("p",[e("img",{attrs:{src:a(948),alt:""}})]),t._v(" "),e("p",[t._v("组队成功，提交有成功有失败情况")]),t._v(" "),e("p",[e("img",{attrs:{src:a(949),alt:""}})]),t._v(" "),e("h2",{attrs:{id:"事务的错误处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务的错误处理"}},[t._v("#")]),t._v(" 事务的错误处理")]),t._v(" "),e("p",[t._v("组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(950),alt:"image-20221110103708277"}})]),t._v(" "),e("p",[t._v("如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(951),alt:"image-20221110104108439"}})]),t._v(" "),e("h2",{attrs:{id:"事务冲突的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事务冲突的问题"}},[t._v("#")]),t._v(" 事务冲突的问题")]),t._v(" "),e("h3",{attrs:{id:"例子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子"}},[t._v("#")]),t._v(" 例子")]),t._v(" "),e("p",[t._v("一个请求想给金额减8000")]),t._v(" "),e("p",[t._v("一个请求想给金额减5000")]),t._v(" "),e("p",[t._v("一个请求想给金额减1000")]),t._v(" "),e("p",[e("img",{attrs:{src:a(952),alt:"image-20221110142439400"}})]),t._v(" "),e("h3",{attrs:{id:"悲观锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#悲观锁"}},[t._v("#")]),t._v(" 悲观锁")]),t._v(" "),e("p",[e("img",{attrs:{src:a(953),alt:"image-20221110142521110"}})]),t._v(" "),e("p",[e("font",{attrs:{color:"red"}},[e("strong",[t._v("悲观锁(Pessimistic Lock)")])]),t._v("， 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。"),e("font",{attrs:{color:"#c00000"}},[e("strong",[t._v("传统的关系型数据库里边就用到了很多这种锁机制")])]),t._v("，比如"),e("strong",[t._v("行锁")]),t._v("，"),e("strong",[t._v("表锁")]),t._v("等，"),e("strong",[t._v("读锁")]),t._v("，"),e("strong",[t._v("写锁")]),t._v("等，都是在做操作之前先上锁。")],1),t._v(" "),e("h3",{attrs:{id:"乐观锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁"}},[t._v("#")]),t._v(" 乐观锁")]),t._v(" "),e("p",[e("img",{attrs:{src:a(954),alt:"image-20221110143117867"}})]),t._v(" "),e("p",[e("font",{attrs:{color:"red"}},[e("strong",[t._v("乐观锁(Optimistic Lock)")])]),t._v("，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。"),e("font",{attrs:{color:"#c00000"}},[e("strong",[t._v("乐观锁适用于多读的应用类型，这样可以提高吞吐量")]),t._v("。Redis就是利用这种check-and-set机制实现事务的。")])],1),t._v(" "),e("h3",{attrs:{id:"watch-key-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#watch-key-key"}},[t._v("#")]),t._v(" WATCH key [key ...]")]),t._v(" "),e("p",[t._v("在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果"),e("font",{attrs:{color:"#007c6a"}},[t._v("在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。")])],1),t._v(" "),e("p",[t._v("启动两个宿主机演示效果")]),t._v(" "),e("p",[e("img",{attrs:{src:a(955),alt:""}})]),t._v(" "),e("p",[e("img",{attrs:{src:a(956),alt:""}})]),t._v(" "),e("h3",{attrs:{id:"unwatch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unwatch"}},[t._v("#")]),t._v(" unwatch")]),t._v(" "),e("p",[t._v("取消 WATCH 命令对所有 key 的监视。")]),t._v(" "),e("p",[t._v("如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://doc.redisfans.com/transaction/exec.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("EXEC — Redis 命令参考 (redisfans.com)"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"redis-事务三特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务三特性"}},[t._v("#")]),t._v(" Redis 事务三特性")]),t._v(" "),e("ul",[e("li",[t._v("单独的隔离操作\n"),e("ul",[e("li",[t._v("事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。")])])]),t._v(" "),e("li",[t._v("没有隔离级别的概念\n"),e("ul",[e("li",[t._v("队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。")])])]),t._v(" "),e("li",[t._v("不保证原子性\n"),e("ul",[e("li",[t._v("事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。")])])])])])}),[],!1,null,null,null);s.default=r.exports},945:function(t,s,a){t.exports=a.p+"assets/img/image-20221110101133247.6c61a350.png"},946:function(t,s,a){t.exports=a.p+"assets/img/image-20221110102258572.28d5e7fb.png"},947:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-11-10_10-32-15.6abe8a34.png"},948:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-11-10_10-33-18.2092ab21.png"},949:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-11-10_10-36-18.705fbe90.png"},950:function(t,s,a){t.exports=a.p+"assets/img/image-20221110103708277.3116771d.png"},951:function(t,s,a){t.exports=a.p+"assets/img/image-20221110104108439.60be8951.png"},952:function(t,s,a){t.exports=a.p+"assets/img/image-20221110142439400.b6ca7600.png"},953:function(t,s,a){t.exports=a.p+"assets/img/image-20221110142521110.c30ab941.png"},954:function(t,s,a){t.exports=a.p+"assets/img/image-20221110143117867.d28e36e2.png"},955:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-11-10_16-15-40.4b8096a4.png"},956:function(t,s,a){t.exports=a.p+"assets/img/Snipaste_2022-11-10_16-16-23.eedf1a27.png"}}]);