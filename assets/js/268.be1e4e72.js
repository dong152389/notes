(window.webpackJsonp=window.webpackJsonp||[]).push([[268],{1398:function(e,t,s){"use strict";s.r(t);var n=s(26),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"docker-compose-实战-redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose-实战-redis"}},[e._v("#")]),e._v(" Docker Compose 实战 Redis")]),e._v(" "),s("h2",{attrs:{id:"创建目录并给权限"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建目录并给权限"}},[e._v("#")]),e._v(" 创建目录并给权限")]),e._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[e._v("mkdir")]),e._v(" -p /home/redis/data /home/redis/logs /home/redis/conf\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("chmod")]),e._v(" -R "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("777")]),e._v(" /home/redis/data*\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("chmod")]),e._v(" -R "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("777")]),e._v(" /home/redis/logs*\n")])])]),s("h2",{attrs:{id:"redis-conf配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-conf配置文件"}},[e._v("#")]),e._v(" redis.conf配置文件")]),e._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("cd")]),e._v(" /home/redis/conf\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("vim")]),e._v(" redis.conf\n")])])]),s("div",{staticClass:"language-properties extra-class"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 记得修改密码，requirepass 后跟上自己的密码，默认为11111")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis configuration file example.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that in order to read the configuration file, Redis must be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# started with the file path as first argument:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ./redis-server /path/to/redis.conf")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note on units: when memory size is needed, it is possible to specify")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# it in the usual form of 1k 5GB 4M and so forth:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1k => 1000 bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1kb => 1024 bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1m => 1000000 bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1mb => 1024*1024 bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1g => 1000000000 bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1gb => 1024*1024*1024 bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# units are case insensitive so 1GB 1Gb 1gB are all the same.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################## INCLUDES ###################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Include one or more other config files here.  This is useful if you")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# have a standard template that goes to all Redis servers but also need")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to customize a few per-server settings.  Include files can include")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# other files, so use this wisely.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# Notice option "include" won\'t be rewritten by command "CONFIG REWRITE"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# from admin or Redis Sentinel. Since Redis always uses the last processed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# line as value of a configuration directive, you'd better put includes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# at the beginning of this file to avoid overwriting config change at runtime.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If instead you are interested in using includes to override configuration")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# options, it is better to use include as the last line.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# include /path/to/local.conf")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# include /path/to/other.conf")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################## MODULES #####################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Load modules at startup. If the server is not able to load modules")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# it will abort. It is possible to use multiple loadmodule directives.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# loadmodule /path/to/my_module.so")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# loadmodule /path/to/other_module.so")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################## NETWORK #####################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# By default, if no "bind" configuration directive is specified, Redis listens')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for connections from all the network interfaces available on the server.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is possible to listen to just one or multiple selected interfaces using")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# the "bind" configuration directive, followed by one or more IP addresses.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Examples:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bind 192.168.1.100 10.0.0.1")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bind 127.0.0.1 ::1")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# internet, binding to all the interfaces is dangerous and will expose the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# instance to everybody on the internet. So by default we uncomment the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# following bind directive, that will force Redis to listen only into")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the IPv4 loopback interface address (this means Redis will be able to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# accept connections only from clients running into the same computer it")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is running).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# JUST COMMENT THE FOLLOWING LINE.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bind 127.0.0.1")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Protected mode is a layer of security protection, in order to avoid that")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis instances left open on the internet are accessed and exploited.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When protected mode is on and if:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) The server is not binding explicitly to a set of addresses using the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#    "bind" directive.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) No password is configured.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The server only accepts connections from clients connecting from the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# IPv4 and IPv6 loopback addresses 127.0.0.1 and ::1, and from Unix domain")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# sockets.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default protected mode is enabled. You should disable it only if")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# you are sure you want clients from other hosts to connect to Redis")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# even if no authentication is configured, nor a specific set of interfaces")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# are explicitly listed using the "bind" directive.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("protected-mode")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Accept connections on the specified port, default is 6379 (IANA #815344).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If port 0 is specified Redis will not listen on a TCP socket.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("port")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("6379")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# TCP listen() backlog.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In high requests-per-second environments you need an high backlog in order")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to avoid slow clients connections issues. Note that the Linux kernel")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will silently truncate it to the value of /proc/sys/net/core/somaxconn so")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# make sure to raise both the value of somaxconn and tcp_max_syn_backlog")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to get the desired effect.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("tcp-backlog")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("511")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Unix socket.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specify the path for the Unix socket that will be used to listen for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# incoming connections. There is no default, so Redis will not listen")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# on a unix socket when not specified.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# unixsocket /tmp/redis.sock")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# unixsocketperm 700")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Close the connection after a client is idle for N seconds (0 to disable)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("timeout")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("0")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# TCP keepalive.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# of communication. This is useful for two reasons:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) Detect dead peers.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) Take the connection alive from the point of view of network")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    equipment in the middle.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# On Linux, the specified value (in seconds) is the period used to send ACKs.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that to close the connection the double of the time is needed.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# On other kernels the period depends on the kernel configuration.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A reasonable value for this option is 300 seconds, which is the new")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis default starting with Redis 3.2.1.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("tcp-keepalive")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("300")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################# GENERAL #####################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default Redis does not run as a daemon. Use 'yes' if you need it.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("daemonize")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If you run Redis from upstart or systemd, Redis can interact with your")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# supervision tree. Options:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   supervised no      - no supervision interaction")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   supervised upstart - signal upstart by putting Redis into SIGSTOP mode")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   supervised auto    - detect upstart or systemd method based on")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#                        UPSTART_JOB or NOTIFY_SOCKET environment variables")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# Note: these supervision methods only signal "process is ready."')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       They do not enable continuous liveness pings back to your supervisor.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("supervised")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If a pid file is specified, Redis writes it where specified at startup")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and removes it at exit.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When the server runs non daemonized, no pid file is created if none is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# specified in the configuration. When the server is daemonized, the pid file")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# is used even if not specified, defaulting to "/var/run/redis.pid".')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Creating a pid file is best effort: if Redis is not able to create it")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# nothing bad happens, the server will start and run normally.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("pidfile")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("/var/run/redis_6379.pid")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specify the server verbosity level.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This can be one of:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# debug (a lot of information, useful for development/testing)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# verbose (many rarely useful info, but not a mess like the debug level)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# notice (moderately verbose, what you want in production probably)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# warning (only very important / critical messages are logged)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("loglevel")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("verbose")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specify the log file name. Also the empty string can be used to force")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis to log on the standard output. Note that if you use standard")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# output for logging but daemonize, logs will be sent to /dev/null")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("logfile")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("/logs/redis.log")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# To enable logging to the system logger, just set 'syslog-enabled' to yes,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and optionally update the other syslog parameters to suit your needs.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# syslog-enabled no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specify the syslog identity.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# syslog-ident redis")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# syslog-facility local0")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set the number of databases. The default database is DB 0, you can select")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a different one on a per-connection basis using SELECT <dbid> where")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# dbid is a number between 0 and 'databases'-1")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("databases")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("16")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default Redis shows an ASCII art logo only when started to log to the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# standard output and if the standard output is a TTY. Basically this means")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that normally a logo is displayed only in interactive sessions.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# However it is possible to force the pre-4.0 behavior and always show a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ASCII art logo in startup logs by setting the following option to yes.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("always-show-logo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################ SNAPSHOTTING  ################################")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Save the DB on disk:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   save <seconds> <changes>")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   Will save the DB if both the given number of seconds and the given")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   number of write operations against the DB occurred.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   In the example below the behaviour will be to save:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   after 900 sec (15 min) if at least 1 key changed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   after 300 sec (5 min) if at least 10 keys changed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   after 60 sec if at least 10000 keys changed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#   Note: you can disable saving completely by commenting out all "save" lines.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   It is also possible to remove all the previously configured save")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   points by adding a save directive with a single empty string argument")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   like in the following example:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#   save ""')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("save")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("900 1")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("save")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("300 10")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("save")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("60 10000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default Redis will stop accepting writes if RDB snapshots are enabled")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# (at least one save point) and the latest background save failed.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This will make the user aware (in a hard way) that data is not persisting")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# on disk properly, otherwise chances are that no one will notice and some")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# disaster will happen.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If the background saving process will start working again Redis will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# automatically allow writes again.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# However if you have setup your proper monitoring of the Redis server")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and persistence, you may want to disable this feature so that Redis will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# continue to work as usual even if there are problems with disk,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# permissions, and so forth.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("stop-writes-on-bgsave-error")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Compress string objects using LZF when dump .rdb databases?")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# For default that's set to 'yes' as it's almost always a win.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If you want to save some CPU in the saving child set it to 'no' but")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the dataset will likely be bigger if you have compressible values or keys.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("rdbcompression")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This makes the format more resistant to corruption but there is a performance")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# hit to pay (around 10%) when saving and loading RDB files, so you can disable it")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for maximum performances.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# RDB files created with checksum disabled have a checksum of zero that will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# tell the loading code to skip the check.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("rdbchecksum")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The filename where to dump the DB")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("dbfilename")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("dump.rdb")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The working directory.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The DB will be written inside this directory, with the filename specified")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# above using the 'dbfilename' configuration directive.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The Append Only File will also be created inside this directory.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that you must specify a directory here, not a file name.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("dir")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("./")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################# REPLICATION #################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Master-Replica replication. Use replicaof to make a Redis instance a copy of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# another Redis server. A few things to understand ASAP about Redis replication.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   +------------------+      +---------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   |      Master      | ---\x3e |    Replica    |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   | (receive writes) |      |  (exact copy) |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   +------------------+      +---------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) Redis replication is asynchronous, but you can configure a master to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    stop accepting writes if it appears to be not connected with at least")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    a given number of replicas.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) Redis replicas are able to perform a partial resynchronization with the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    master if the replication link is lost for a relatively small amount of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    time. You may want to configure the replication backlog size (see the next")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    sections of this file) with a sensible value depending on your needs.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 3) Replication is automatic and does not need user intervention. After a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    network partition replicas automatically try to reconnect to masters")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    and resynchronize with them.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replicaof <masterip> <masterport>")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# If the master is password protected (using the "requirepass" configuration')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# directive below) it is possible to tell the replica to authenticate before")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# starting the replication synchronization process, otherwise the master will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# refuse the replica request.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# masterauth <master-password>")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When a replica loses its connection with the master, or when the replication")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is still in progress, the replica can act in two different ways:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    still reply to client requests, possibly with out of date data, or the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    data set may just be empty if this is the first synchronization.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) if replica-serve-stale-data is set to 'no' the replica will reply with")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#    an error "SYNC with master in progress" to all the kind of commands')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    COMMAND, POST, HOST: and LATENCY.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("replica-serve-stale-data")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# You can configure a replica instance to accept writes or not. Writing against")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a replica instance may be useful to store some ephemeral data (because data")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# written on a replica will be easily deleted after resync with the master) but")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# may also cause problems if clients are writing to it because of a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# misconfiguration.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Since Redis 2.6 by default replicas are read-only.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note: read only replicas are not designed to be exposed to untrusted clients")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# on the internet. It's just a protection layer against misuse of the instance.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Still a read only replica exports by default all the administrative commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# such as CONFIG, DEBUG, and so forth. To a limited extent you can improve")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# security of read only replicas using 'rename-command' to shadow all the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# administrative / dangerous commands.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("replica-read-only")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Replication SYNC strategy: disk or socket.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -------------------------------------------------------")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# WARNING: DISKLESS REPLICATION IS EXPERIMENTAL CURRENTLY")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -------------------------------------------------------")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# New replicas and reconnecting replicas that are not able to continue the replication")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# process just receiving differences, need to do what is called a "full')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# synchronization". An RDB file is transmitted from the master to the replicas.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The transmission can happen in two different ways:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) Disk-backed: The Redis master creates a new process that writes the RDB")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#                 file on disk. Later the file is transferred by the parent")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#                 process to the replicas incrementally.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) Diskless: The Redis master creates a new process that directly writes the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#              RDB file to replica sockets, without touching the disk at all.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# With disk-backed replication, while the RDB file is generated, more replicas")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# can be queued and served with the RDB file as soon as the current child producing")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the RDB file finishes its work. With diskless replication instead once")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the transfer starts, new replicas arriving will be queued and a new transfer")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will start when the current one terminates.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When diskless replication is used, the master waits a configurable amount of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# time (in seconds) before starting the transfer in the hope that multiple replicas")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will arrive and the transfer can be parallelized.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# With slow disks and fast (large bandwidth) networks, diskless replication")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# works better.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("repl-diskless-sync")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When diskless replication is enabled, it is possible to configure the delay")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the server waits in order to spawn the child that transfers the RDB via socket")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to the replicas.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This is important since once the transfer starts, it is not possible to serve")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# new replicas arriving, that will be queued for the next RDB transfer, so the server")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# waits a delay in order to let more replicas arrive.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The delay is specified in seconds, and by default is 5 seconds. To disable")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# it entirely just set it to 0 seconds and the transfer will start ASAP.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("repl-diskless-sync-delay")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("5")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Replicas send PINGs to server in a predefined interval. It's possible to change")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# this interval with the repl_ping_replica_period option. The default value is 10")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# seconds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# repl-ping-replica-period 10")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The following option sets the replication timeout for:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) Bulk transfer I/O during SYNC, from the point of view of replica.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) Master timeout from the point of view of replicas (data, pings).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 3) Replica timeout from the point of view of masters (REPLCONF ACK pings).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is important to make sure that this value is greater than the value")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# specified for repl-ping-replica-period otherwise a timeout will be detected")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# every time there is low traffic between the master and the replica.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# repl-timeout 60")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Disable TCP_NODELAY on the replica socket after SYNC?")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# If you select "yes" Redis will use a smaller number of TCP packets and')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# less bandwidth to send data to replicas. But this can add a delay for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the data to appear on the replica side, up to 40 milliseconds with")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Linux kernels using a default configuration.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# If you select "no" the delay for data to appear on the replica side will')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# be reduced but more bandwidth will be used for replication.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default we optimize for low latency, but in very high traffic conditions")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# or when the master and replicas are many hops away, turning this to "yes" may')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# be a good idea.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("repl-disable-tcp-nodelay")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set the replication backlog size. The backlog is a buffer that accumulates")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica data when replicas are disconnected for some time, so that when a replica")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# wants to reconnect again, often a full resync is not needed, but a partial")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# resync is enough, just passing the portion of data the replica missed while")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# disconnected.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The bigger the replication backlog, the longer the time the replica can be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# disconnected and later be able to perform a partial resynchronization.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The backlog is only allocated once there is at least a replica connected.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# repl-backlog-size 1mb")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# After a master has no longer connected replicas for some time, the backlog")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will be freed. The following option configures the amount of seconds that")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# need to elapse, starting from the time the last replica disconnected, for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the backlog buffer to be freed.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that replicas never free the backlog for timeout, since they may be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# promoted to masters later, and should be able to correctly "partially')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# resynchronize" with the replicas: hence they should always accumulate backlog.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A value of 0 means to never release the backlog.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# repl-backlog-ttl 3600")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The replica priority is an integer number published by Redis in the INFO output.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is used by Redis Sentinel in order to select a replica to promote into a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# master if the master is no longer working correctly.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A replica with a low priority number is considered better for promotion, so")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for instance if there are three replicas with priority 10, 100, 25 Sentinel will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# pick the one with priority 10, that is the lowest.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# However a special priority of 0 marks the replica as not able to perform the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# role of master, so a replica with priority of 0 will never be selected by")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis Sentinel for promotion.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default the priority is 100.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("replica-priority")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("100")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is possible for a master to stop accepting writes if there are less than")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# N replicas connected, having a lag less or equal than M seconds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# The N replicas need to be in "online" state.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The lag in seconds, that must be <= the specified value, is calculated from")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the last ping received from the replica, that is usually sent every second.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This option does not GUARANTEE that N replicas will accept the write, but")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will limit the window of exposure for lost writes in case not enough replicas")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# are available, to the specified number of seconds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# For example to require at least 3 replicas with a lag <= 10 seconds use:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# min-replicas-to-write 3")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# min-replicas-max-lag 10")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Setting one or the other to 0 disables the feature.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default min-replicas-to-write is set to 0 (feature disabled) and")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# min-replicas-max-lag is set to 10.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A Redis master is able to list the address and port of the attached")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# replicas in different ways. For example the "INFO replication" section')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# offers this information, which is used, among other tools, by")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis Sentinel in order to discover replica instances.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Another place where this info is available is in the output of the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# "ROLE" command of a master.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The listed IP and address normally reported by a replica is obtained")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in the following way:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   IP: The address is auto detected by checking the peer address")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   of the socket used by the replica to connect with the master.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   Port: The port is communicated by the replica during the replication")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   handshake, and is normally the port that the replica is using to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   listen for connections.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# However when port forwarding or Network Address Translation (NAT) is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# used, the replica may be actually reachable via different IP and port")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# pairs. The following two options can be used by a replica in order to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# report to its master a specific set of IP and port, so that both INFO")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and ROLE will report those values.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# There is no need to use both the options if you need to override just")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the port or the IP address.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica-announce-ip 5.5.5.5")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica-announce-port 1234")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################## SECURITY ###################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Require clients to issue AUTH <PASSWORD> before processing any other")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# commands.  This might be useful in environments in which you do not trust")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# others with access to the host running redis-server.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This should stay commented out for backward compatibility and because most")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# people do not need auth (e.g. they run their own servers).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Warning: since Redis is pretty fast an outside user can try up to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 150k passwords per second against a good box. This means that you should")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# use a very strong password otherwise it will be very easy to break.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# requirepass foobared")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("requirepass")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("111111")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Command renaming.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is possible to change the name of dangerous commands in a shared")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# environment. For instance the CONFIG command may be renamed into something")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# hard to guess so that it will still be available for internal-use tools")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# but not available for general clients.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Example:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is also possible to completely kill a command by renaming it into")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# an empty string:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# rename-command CONFIG ""')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Please note that changing the name of commands that are logged into the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# AOF file or transmitted to replicas may cause problems.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################### CLIENTS ####################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set the max number of connected clients at the same time. By default")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# this limit is set to 10000 clients, however if the Redis server is not")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# able to configure the process file limit to allow for the specified limit")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the max number of allowed clients is set to the current file limit")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# minus 32 (as Redis reserves a few file descriptors for internal uses).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Once the limit is reached Redis will close all the new connections sending")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# an error 'max number of clients reached'.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# maxclients 10000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("############################## MEMORY MANAGEMENT ################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set a memory usage limit to the specified amount of bytes.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When the memory limit is reached Redis will try to remove keys")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# according to the eviction policy selected (see maxmemory-policy).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If Redis can't remove keys according to the policy, or if the policy is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# set to 'noeviction', Redis will start to reply with errors to commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that would use more memory, like SET, LPUSH, and so on, and will continue")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to reply to read-only commands like GET.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This option is usually useful when using Redis as an LRU or LFU cache, or to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# set a hard memory limit for an instance (using the 'noeviction' policy).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# WARNING: If you have replicas attached to an instance with maxmemory on,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the size of the output buffers needed to feed the replicas are subtracted")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# from the used memory count, so that network problems / resyncs will")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# not trigger a loop where keys are evicted, and in turn the output")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# buffer of replicas is full with DELs of keys evicted triggering the deletion")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# of more keys, and so forth until the database is completely emptied.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In short... if you have replicas attached it is suggested that you set a lower")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# limit for maxmemory so that there is some free RAM on the system for replica")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# output buffers (but this is not needed if the policy is 'noeviction').")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# maxmemory <bytes>")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is reached. You can select among five behaviors:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# volatile-lru -> Evict using approximated LRU among the keys with an expire set.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# allkeys-lru -> Evict any key using approximated LRU.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# volatile-lfu -> Evict using approximated LFU among the keys with an expire set.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# allkeys-lfu -> Evict any key using approximated LFU.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# volatile-random -> Remove a random key among the ones with an expire set.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# allkeys-random -> Remove a random key, any key.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# volatile-ttl -> Remove the key with the nearest expire time (minor TTL)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# noeviction -> Don't evict anything, just return an error on write operations.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# LRU means Least Recently Used")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# LFU means Least Frequently Used")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Both LRU, LFU and volatile-ttl are implemented using approximated")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# randomized algorithms.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note: with any of the above policies, Redis will return an error on write")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       operations, when there are no suitable keys for eviction.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       At the date of writing these commands are: set setnx setex append")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#       getset mset msetnx exec sort")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The default is:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# maxmemory-policy noeviction")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# algorithms (in order to save memory), so you can tune it for speed or")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# accuracy. For default Redis will check five keys and pick the one that was")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# used less recently, you can change the sample size using the following")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# configuration directive.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The default of 5 produces good enough results. 10 Approximates very closely")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# true LRU but costs more CPU. 3 is faster but not very accurate.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# maxmemory-samples 5")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Starting from Redis 5, by default a replica will ignore its maxmemory setting")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# (unless it is promoted to master after a failover or manually). It means")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that the eviction of keys will be just handled by the master, sending the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# DEL commands to the replica as keys evict in the master side.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This behavior ensures that masters and replicas stay consistent, and is usually")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# what you want, however if your replica is writable, or you want the replica to have")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a different memory setting, and you are sure all the writes performed to the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica are idempotent, then you may change this default (but be sure to understand")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# what you are doing).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that since the replica by default does not evict, it may end using more")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# memory than the one set via maxmemory (there are certain buffers that may")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# be larger on the replica, or data structures may sometimes take more memory and so")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# forth). So make sure you monitor your replicas and make sure they have enough")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# memory to never hit a real out-of-memory condition before the master hits")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the configured maxmemory setting.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica-ignore-maxmemory yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("############################# LAZY FREEING ####################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis has two primitives to delete keys. One is called DEL and is a blocking")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# deletion of the object. It means that the server stops processing new commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to reclaim all the memory associated with an object in a synchronous")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# way. If the key deleted is associated with a small object, the time needed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to execute the DEL command is very small and comparable to most other")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# O(1) or O(log_N) commands in Redis. However if the key is associated with an")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# aggregated value containing millions of elements, the server can block for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a long time (even seconds) in order to complete the operation.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# For the above reasons Redis also offers non blocking deletion primitives")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# FLUSHDB commands, in order to reclaim memory in background. Those commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# are executed in constant time. Another thread will incrementally free the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# object in the background as fast as possible.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# DEL, UNLINK and ASYNC option of FLUSHALL and FLUSHDB are user-controlled.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It's up to the design of the application to understand when it is a good")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# idea to use one or the other. However the Redis server sometimes has to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# delete keys or flush the whole database as a side effect of other operations.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specifically Redis deletes objects independently of a user call in the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# following scenarios:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) On eviction, because of the maxmemory and maxmemory policy configurations,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    in order to make room for new data, without going over the specified")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    memory limit.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) Because of expire: when a key with an associated time to live (see the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    EXPIRE command) must be deleted from memory.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 3) Because of a side effect of a command that stores data on a key that may")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    already exist. For example the RENAME command may delete the old key")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    content when it is replaced with another one. Similarly SUNIONSTORE")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    or SORT with STORE option may delete existing keys. The SET command")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    itself removes any old content of the specified key in order to replace")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    it with the specified string.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 4) During replication, when a replica performs a full resynchronization with")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    its master, the content of the whole database is removed in order to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    load the RDB file just transferred.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In all the above cases the default is to delete objects in a blocking way,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# like if DEL was called. However you can configure each case specifically")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to instead release memory in a non-blocking way like if UNLINK")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# was called, using the following configuration directives:")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("lazyfree-lazy-eviction")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("lazyfree-lazy-expire")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("lazyfree-lazy-server-del")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("replica-lazy-flush")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("############################## APPEND ONLY MODE ###############################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default Redis asynchronously dumps the dataset on disk. This mode is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# good enough in many applications, but an issue with the Redis process or")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a power outage may result into a few minutes of writes lost (depending on")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the configured save points).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The Append Only File is an alternative persistence mode that provides")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# much better durability. For instance using the default data fsync policy")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# (see later in the config file) Redis can lose just one second of writes in a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# dramatic event like a server power outage, or a single write if something")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# wrong with the Redis process itself happens, but the operating system is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# still running correctly.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# AOF and RDB persistence can be enabled at the same time without problems.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If the AOF is enabled on startup Redis will load the AOF, that is the file")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# with the better durability guarantees.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Please check http://redis.io/topics/persistence for more information.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("appendonly")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# The name of the append only file (default: "appendonly.aof")')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("appendfilename")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v('"appendonly.aof"')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The fsync() call tells the Operating System to actually write data on disk")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# instead of waiting for more data in the output buffer. Some OS will really flush")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# data on disk, some other OS will just try to do it ASAP.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis supports three different modes:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# no: don't fsync, just let the OS flush the data when it wants. Faster.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# always: fsync after every write to the append only log. Slow, Safest.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# everysec: fsync only one time every second. Compromise.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# The default is "everysec", as that\'s usually the right compromise between')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# speed and data safety. It's up to you to understand if you can relax this to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# "no" that will let the operating system flush the output buffer when')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# it wants, for better performances (but if you can live with the idea of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# some data loss consider the default persistence mode that's snapshotting),")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# or on the contrary, use "always" that\'s very slow but a bit safer than')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# everysec.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# More details please check the following article:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# http://antirez.com/post/redis-persistence-demystified.html")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# If unsure, use "everysec".')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appendfsync always")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("appendfsync")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("everysec")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appendfsync no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When the AOF fsync policy is set to always or everysec, and a background")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# saving process (a background save or AOF log background rewriting) is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# performing a lot of I/O against the disk, in some Linux configurations")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis may block too long on the fsync() call. Note that there is no fix for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# this currently, as even performing fsync in a different thread will block")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# our synchronous write(2) call.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In order to mitigate this problem it's possible to use the following option")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that will prevent fsync() from being called in the main process while a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# BGSAVE or BGREWRITEAOF is in progress.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This means that while another child is saving, the durability of Redis is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# the same as "appendfsync none". In practical terms, this means that it is')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# possible to lose up to 30 seconds of log in the worst scenario (with the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# default Linux settings).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# If you have latency problems turn this to "yes". Otherwise leave it as')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# "no" that is the safest pick from the point of view of durability.')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("no-appendfsync-on-rewrite")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Automatic rewrite of the append only file.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis is able to automatically rewrite the log file implicitly calling")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# BGREWRITEAOF when the AOF log size grows by the specified percentage.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This is how it works: Redis remembers the size of the AOF file after the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# latest rewrite (if no rewrite has happened since the restart, the size of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the AOF at startup is used).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This base size is compared to the current size. If the current size is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bigger than the specified percentage, the rewrite is triggered. Also")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# you need to specify a minimal size for the AOF file to be rewritten, this")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is useful to avoid rewriting the AOF file even if the percentage increase")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is reached but it is still pretty small.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Specify a percentage of zero in order to disable the automatic AOF")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# rewrite feature.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("auto-aof-rewrite-percentage")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("100")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("auto-aof-rewrite-min-size")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("64mb")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# An AOF file may be found to be truncated at the end during the Redis")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# startup process, when the AOF data gets loaded back into memory.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This may happen when the system where Redis is running")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# crashes, especially when an ext4 filesystem is mounted without the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# data=ordered option (however this can't happen when Redis itself")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# crashes or aborts but the operating system still works correctly).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis can either exit with an error when this happens, or load as much")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# data as possible (the default now) and start if the AOF file is found")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to be truncated at the end. The following option controls this behavior.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If aof-load-truncated is set to yes, a truncated AOF file is loaded and")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the Redis server starts emitting a log to inform the user of the event.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Otherwise if the option is set to no, the server aborts with an error")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and refuses to start. When the option is set to no, the user requires")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# to fix the AOF file using the "redis-check-aof" utility before to restart')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the server.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that if the AOF file will be found to be corrupted in the middle")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the server will still exit with an error. This option only applies when")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis will try to read more data from the AOF file but not enough bytes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will be found.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("aof-load-truncated")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When rewriting the AOF file, Redis is able to use an RDB preamble in the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# AOF file for faster rewrites and recoveries. When this option is turned")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# on the rewritten AOF file is composed of two different stanzas:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   [RDB file][AOF tail]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# When loading Redis recognizes that the AOF file starts with the "REDIS"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# string and loads the prefixed RDB file, and continues loading the AOF")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# tail.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("aof-use-rdb-preamble")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################ LUA SCRIPTING  ###############################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Max execution time of a Lua script in milliseconds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If the maximum execution time is reached Redis will log that a script is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# still in execution after the maximum allowed time and will start to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# reply to queries with an error.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When a long running script exceeds the maximum execution time only the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# used to stop a script that did not yet called write commands. The second")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is the only way to shut down the server in the case a write command was")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# already issued by the script but the user doesn't want to wait for the natural")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# termination of the script.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set it to 0 or a negative value for unlimited execution without warnings.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("lua-time-limit")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("5000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################ REDIS CLUSTER  ###############################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Normal Redis instances can't be part of a Redis Cluster; only nodes that are")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# started as cluster nodes can. In order to start a Redis instance as a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster node enable the cluster support uncommenting the following:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-enabled yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Every cluster node has a cluster configuration file. This file is not")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# intended to be edited by hand. It is created and updated by Redis nodes.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Every Redis Cluster node requires a different cluster configuration file.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Make sure that instances running in the same system do not have")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# overlapping cluster configuration file names.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-config-file nodes-6379.conf")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Cluster node timeout is the amount of milliseconds a node must be unreachable")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for it to be considered in failure state.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Most other internal time limits are multiple of the node timeout.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-node-timeout 15000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A replica of a failing master will avoid to start a failover if its data")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# looks too old.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# There is no simple way for a replica to actually have an exact measure of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# its "data age", so the following two checks are performed:')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1) If there are multiple replicas able to failover, they exchange messages")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    in order to try to give an advantage to the replica with the best")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    replication offset (more data from the master processed).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    Replicas will try to get their rank by offset, and apply to the start")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    of the failover a delay proportional to their rank.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2) Every single replica computes the time of the last interaction with")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    its master. This can be the last ping or command received (if the master")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#    is still in the "connected" state), or the time that elapsed since the')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    disconnection with the master (if the replication link is currently down).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    If the last interaction is too old, the replica will not try to failover")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    at all.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# The point "2" can be tuned by user. Specifically a replica will not perform')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the failover if, since the last interaction with the master, the time")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# elapsed is greater than:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   (node-timeout * replica-validity-factor) + repl-ping-replica-period")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# So for example if node-timeout is 30 seconds, and the replica-validity-factor")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is 10, and assuming a default repl-ping-replica-period of 10 seconds, the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica will not try to failover if it was not able to talk with the master")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for longer than 310 seconds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A large replica-validity-factor may allow replicas with too old data to failover")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a master, while a too small value may prevent the cluster from being able to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# elect a replica at all.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# For maximum availability, it is possible to set the replica-validity-factor")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to a value of 0, which means, that replicas will always try to failover the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# master regardless of the last time they interacted with the master.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# (However they'll always try to apply a delay proportional to their")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# offset rank).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Zero is the only value able to guarantee that when all the partitions heal")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the cluster will always be able to continue.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-replica-validity-factor 10")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Cluster replicas are able to migrate to orphaned masters, that are masters")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that are left without working replicas. This improves the cluster ability")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to resist to failures as otherwise an orphaned master can't be failed over")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in case of failure if it has no working replicas.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Replicas migrate to orphaned masters only if there are still at least a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# given number of other working replicas for their old master. This number")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# is the "migration barrier". A migration barrier of 1 means that a replica')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will migrate only if there is at least 1 other working replica for its master")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and so forth. It usually reflects the number of replicas you want for every")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# master in your cluster.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Default is 1 (replicas migrate only if their masters remain with at least")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# one replica). To disable migration just set it to a very large value.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A value of 0 can be set but is useful only for debugging and dangerous")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in production.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-migration-barrier 1")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default Redis Cluster nodes stop accepting queries if they detect there")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is at least an hash slot uncovered (no available node is serving it).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This way if the cluster is partially down (for example a range of hash slots")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# are no longer covered) all the cluster becomes, eventually, unavailable.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It automatically returns available as soon as all the slots are covered again.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# However sometimes you want the subset of the cluster which is working,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to continue to accept queries for the part of the key space that is still")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# covered. In order to do so, just set the cluster-require-full-coverage")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# option to no.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-require-full-coverage yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This option, when set to yes, prevents replicas from trying to failover its")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# master during master failures. However the master can still perform a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# manual failover, if forced to do so.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This is useful in different scenarios, especially in the case of multiple")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# data center operations, where we want one side to never be promoted if not")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in the case of a total DC failure.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-replica-no-failover no")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In order to setup your cluster make sure to read the documentation")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# available at http://redis.io web site.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("########################## CLUSTER DOCKER/NAT support  ########################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In certain deployments, Redis Cluster nodes address discovery fails, because")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# addresses are NAT-ted or because ports are forwarded (the typical case is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Docker and other containers).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In order to make Redis Cluster working in such environments, a static")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# configuration where each node knows its public address is needed. The")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# following two options are used for this scope, and are:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# * cluster-announce-ip")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# * cluster-announce-port")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# * cluster-announce-bus-port")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Each instruct the node about its address, client port, and cluster message")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bus port. The information is then published in the header of the bus packets")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# so that other nodes will be able to correctly map the address of the node")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# publishing the information.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If the above options are not used, the normal Redis Cluster auto-detection")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will be used instead.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that when remapped, the bus port may not be at the fixed offset of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# clients port + 10000, so you can specify any port and bus-port depending")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# on how they get remapped. If the bus-port is not set, a fixed offset of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 10000 will be used as usually.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Example:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-announce-ip 10.1.1.5")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-announce-port 6379")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# cluster-announce-bus-port 6380")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################## SLOW LOG ###################################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The Redis Slow Log is a system to log queries that exceeded a specified")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# execution time. The execution time does not include the I/O operations")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# like talking with the client, sending the reply and so forth,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# but just the time needed to actually execute the command (this is the only")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# stage of command execution where the thread is blocked and can not serve")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# other requests in the meantime).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# You can configure the slow log with two parameters: one tells Redis")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# what is the execution time, in microseconds, to exceed in order for the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# command to get logged, and the other parameter is the length of the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# slow log. When a new command is logged the oldest one is removed from the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# queue of logged commands.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The following time is expressed in microseconds, so 1000000 is equivalent")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to one second. Note that a negative number disables the slow log, while")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a value of zero forces the logging of every command.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("slowlog-log-slower-than")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("10000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# There is no limit to this length. Just be aware that it will consume memory.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# You can reclaim memory used by the slow log with SLOWLOG RESET.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("slowlog-max-len")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("128")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("################################ LATENCY MONITOR ##############################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The Redis latency monitoring subsystem samples different operations")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# at runtime in order to collect data related to possible sources of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# latency of a Redis instance.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Via the LATENCY command this information is available to the user that can")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# print graphs and obtain reports.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The system only logs operations that were performed in a time equal or")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# greater than the amount of milliseconds specified via the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# latency-monitor-threshold configuration directive. When its value is set")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to zero, the latency monitor is turned off.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default latency monitoring is disabled since it is mostly not needed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# if you don't have latency issues, and collecting data has a performance")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# impact, that while very small, can be measured under big load. Latency")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# monitoring can easily be enabled at runtime using the command")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("latency-monitor-threshold")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("0")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("############################# EVENT NOTIFICATION ##############################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis can notify Pub/Sub clients about events happening in the key space.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This feature is documented at http://redis.io/topics/notifications")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# For instance if keyspace events notification is enabled, and a client")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# performs a DEL operation on key "foo" stored in the Database 0, two')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# messages will be published via Pub/Sub:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# PUBLISH __keyspace@0__:foo del")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# PUBLISH __keyevent@0__:del foo")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is possible to select the events that Redis will notify among a set")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# of classes. Every class is identified by a single character:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  K     Keyspace events, published with __keyspace@<db>__ prefix.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  E     Keyevent events, published with __keyevent@<db>__ prefix.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  $     String commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  l     List commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  s     Set commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  h     Hash commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  z     Sorted set commands")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  x     Expired events (events generated every time a key expires)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  e     Evicted events (events generated when a key is evicted for maxmemory)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#  The "notify-keyspace-events" takes as argument a string that is composed')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  of zero or multiple characters. The empty string means that notifications")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  are disabled.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  Example: to enable list and generic events, from the point of view of the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#           event name, use:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  notify-keyspace-events Elg")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  Example 2: to get the stream of the expired keys subscribing to channel")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#             name __keyevent@0__:expired use:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  notify-keyspace-events Ex")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  By default all notifications are disabled because most users don't need")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  this feature and the feature has some overhead. Note that if you don't")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#  specify at least one of K or E, no events will be delivered.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("notify-keyspace-events")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v('""')]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("############################### ADVANCED CONFIG ###############################")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Hashes are encoded using a memory efficient data structure when they have a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# small number of entries, and the biggest entry does not exceed a given")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# threshold. These thresholds can be configured using the following directives.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("hash-max-ziplist-entries")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("512")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("hash-max-ziplist-value")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("64")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Lists are also encoded in a special way to save a lot of space.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The number of entries allowed per internal list node can be specified")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# as a fixed maximum size or a maximum number of elements.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# For a fixed maximum size, use -5 through -1, meaning:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -5: max size: 64 Kb  <-- not recommended for normal workloads")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -4: max size: 32 Kb  <-- not recommended")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -3: max size: 16 Kb  <-- probably not recommended")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -2: max size: 8 Kb   <-- good")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -1: max size: 4 Kb   <-- good")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Positive numbers mean store up to _exactly_ that number of elements")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# per list node.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The highest performing option is usually -2 (8 Kb size) or -1 (4 Kb size),")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# but if your use case is unique, adjust the settings as necessary.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("list-max-ziplist-size")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("-2")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Lists may also be compressed.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Compress depth is the number of quicklist ziplist nodes from *each* side of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the list to *exclude* from compression.  The head and tail of the list")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# are always uncompressed for fast push/pop operations.  Settings are:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 0: disable all list compression")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1: depth 1 means \"don't start compressing until after 1 node into the list,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#    going from either the head or tail"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    So: [head]->node->node->...->node->[tail]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    [head], [tail] will always be uncompressed; inner nodes will compress.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2: [head]->[next]->node->node->...->node->[prev]->[tail]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    2 here means: don't compress head or head->next or tail->prev or tail,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    but compress all nodes between them.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 3: [head]->[next]->[next]->node->node->...->node->[prev]->[prev]->[tail]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# etc.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("list-compress-depth")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("0")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Sets have a special encoding in just one case: when a set is composed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# of just strings that happen to be integers in radix 10 in the range")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# of 64 bit signed integers.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The following configuration setting sets the limit in the size of the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# set in order to use this special memory saving encoding.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("set-max-intset-entries")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("512")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Similarly to hashes and lists, sorted sets are also specially encoded in")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# order to save a lot of space. This encoding is only used when the length and")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# elements of a sorted set are below the following limits:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("zset-max-ziplist-entries")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("128")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("zset-max-ziplist-value")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("64")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# HyperLogLog sparse representation bytes limit. The limit includes the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 16 bytes header. When an HyperLogLog using the sparse representation crosses")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# this limit, it is converted into the dense representation.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A value greater than 16000 is totally useless, since at that point the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# dense representation is more memory efficient.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The suggested value is ~ 3000 in order to have the benefits of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the space efficient encoding without slowing down too much PFADD,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# which is O(N) with the sparse encoding. The value can be raised to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ~ 10000 when CPU is not a concern, but space is, and the data set is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# composed of many HyperLogLogs with cardinality in the 0 - 15000 range.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("hll-sparse-max-bytes")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("3000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Streams macro node max size / items. The stream data structure is a radix")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# tree of big nodes that encode multiple items inside. Using this configuration")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# it is possible to configure how big a single node can be in bytes, and the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# maximum number of items it may contain before switching to a new node when")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# appending new stream entries. If any of the following settings are set to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# zero, the limit is ignored, so for instance it is possible to set just a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# max entires limit by setting max-bytes to 0 and max-entries to the desired")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# value.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("stream-node-max-bytes")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("4096")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("stream-node-max-entries")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("100")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# order to help rehashing the main Redis hash table (the one mapping top-level")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# keys to values). The hash table implementation Redis uses (see dict.c)")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# performs a lazy rehashing: the more operation you run into a hash table")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# that is rehashing, the more rehashing "steps" are performed, so if the')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# server is idle the rehashing is never complete and some more memory is used")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# by the hash table.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The default is to use this millisecond 10 times every second in order to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# actively rehash the main dictionaries, freeing memory when possible.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If unsure:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# use "activerehashing no" if you have hard latency requirements and it is')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# not a good thing in your environment that Redis can reply from time to time")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to queries with 2 milliseconds delay.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# use "activerehashing yes" if you don\'t have such hard requirements but')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# want to free memory asap when possible.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("activerehashing")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The client output buffer limits can be used to force disconnection of clients")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that are not reading data from the server fast enough for some reason (a")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# common reason is that a Pub/Sub client can't consume messages as fast as the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# publisher can produce them).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The limit can be set differently for the three different classes of clients:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# normal -> normal clients including MONITOR clients")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# replica  -> replica clients")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# pubsub -> clients subscribed to at least one pubsub channel or pattern")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The syntax of every client-output-buffer-limit directive is the following:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# A client is immediately disconnected once the hard limit is reached, or if")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the soft limit is reached and remains reached for the specified number of")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# seconds (continuously).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# So for instance if the hard limit is 32 megabytes and the soft limit is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 16 megabytes / 10 seconds, the client will get disconnected immediately")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# if the size of the output buffers reach 32 megabytes, but will also get")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# disconnected if the client reaches 16 megabytes and continuously overcomes")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the limit for 10 seconds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# By default normal clients are not limited because they don't receive data")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# without asking (in a push way), but just after a request, so only")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# asynchronous clients may create a scenario where data is requested faster")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# than it can read.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Instead there is a default limit for pubsub and replica clients, since")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# subscribers and replicas receive data in a push fashion.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Both the hard or the soft limit can be disabled by setting them to zero.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("client-output-buffer-limit")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("normal 0 0 0")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("client-output-buffer-limit")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("replica 256mb 64mb 60")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("client-output-buffer-limit")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("pubsub 32mb 8mb 60")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Client query buffers accumulate new commands. They are limited to a fixed")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# amount by default in order to avoid that a protocol desynchronization (for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# instance due to a bug in the client) will lead to unbound memory usage in")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the query buffer. However you can configure it here if you have very special")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# needs, such us huge multi/exec requests or alike.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# client-query-buffer-limit 1gb")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In the Redis protocol, bulk requests, that are, elements representing single")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# strings, are normally limited ot 512 mb. However you can change this limit")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# here.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# proto-max-bulk-len 512mb")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis calls an internal function to perform many background tasks, like")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# closing connections of clients in timeout, purging expired keys that are")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# never requested, and so forth.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Not all tasks are performed with the same frequency, but Redis checks for")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# tasks to perform according to the specified "hz" value.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# By default "hz" is set to 10. Raising the value will use more CPU when')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis is idle, but at the same time will make Redis more responsive when")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# there are many keys expiring at the same time, and timeouts may be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# handled with more precision.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The range is between 1 and 500, however a value over 100 is usually not")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a good idea. Most users should use the default of 10 and raise this up to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 100 only in environments where very low latency is required.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("hz")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("10")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Normally it is useful to have an HZ value which is proportional to the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# number of clients connected. This is useful in order, for instance, to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# avoid too many clients are processed for each background task invocation")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to avoid latency spikes.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Since the default HZ value by default is conservatively set to 10, Redis")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# offers, and enables by default, the ability to use an adaptive HZ value")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# which will temporary raise when there are many connected clients.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When dynamic HZ is enabled, the actual configured HZ will be used as")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# as a baseline, but multiples of the configured HZ value will be actually")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# used as needed once more clients are connected. In this way an idle")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# instance will use very little CPU time while a busy instance will be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# more responsive.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("dynamic-hz")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When a child rewrites the AOF file, if the following option is enabled")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the file will be fsync-ed every 32 MB of data generated. This is useful")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to commit the file to the disk more incrementally and avoid")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# big latency spikes.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("aof-rewrite-incremental-fsync")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# When redis saves RDB file, if the following option is enabled")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the file will be fsync-ed every 32 MB of data generated. This is useful")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in order to commit the file to the disk more incrementally and avoid")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# big latency spikes.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("rdb-save-incremental-fsync")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token attr-value"}},[e._v("yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Redis LFU eviction (see maxmemory setting) can be tuned. However it is a good")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# idea to start with the default settings and only change them after investigating")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# how to improve the performances and how the keys LFU change over time, which")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# is possible to inspect via the OBJECT FREQ command.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# There are two tunable parameters in the Redis LFU implementation: the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# counter logarithm factor and the counter decay time. It is important to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# understand what the two parameters mean before changing them.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The LFU counter is just 8 bits per key, it's maximum value is 255, so Redis")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# uses a probabilistic increment with logarithmic behavior. Given the value")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# of the old counter, when a key is accessed, the counter is incremented in")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# this way:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1. A random number R between 0 and 1 is extracted.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2. A probability P is calculated as 1/(old_value*lfu_log_factor+1).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 3. The counter is incremented only if R < P.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The default lfu-log-factor is 10. This is a table of how the frequency")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# counter changes with a different number of accesses with different")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# logarithmic factors:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# +--------+------------+------------+------------+------------+------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# | factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# +--------+------------+------------+------------+------------+------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# | 0      | 104        | 255        | 255        | 255        | 255        |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# +--------+------------+------------+------------+------------+------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# | 1      | 18         | 49         | 255        | 255        | 255        |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# +--------+------------+------------+------------+------------+------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# | 10     | 10         | 18         | 142        | 255        | 255        |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# +--------+------------+------------+------------+------------+------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# | 100    | 8          | 11         | 49         | 143        | 255        |")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# +--------+------------+------------+------------+------------+------------+")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# NOTE: The above table was obtained by running the following commands:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   redis-benchmark -n 1000000 incr foo")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#   redis-cli object freq foo")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# NOTE 2: The counter initial value is 5 in order to give new objects a chance")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to accumulate hits.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The counter decay time is the time, in minutes, that must elapse in order")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for the key counter to be divided by two (or decremented if it has a value")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# less <= 10).")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The default value for the lfu-decay-time is 1. A Special value of 0 means to")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# decay the counter every time it happens to be scanned.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# lfu-log-factor 10")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# lfu-decay-time 1")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("########################### ACTIVE DEFRAGMENTATION #######################")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# WARNING THIS FEATURE IS EXPERIMENTAL. However it was stress tested")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# even in production and manually tested by multiple engineers for some")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# time.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# What is active defragmentation?")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# -------------------------------")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Active (online) defragmentation allows a Redis server to compact the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# spaces left between small allocations and deallocations of data in memory,")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# thus allowing to reclaim back memory.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Fragmentation is a natural process that happens with every allocator (but")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# less so with Jemalloc, fortunately) and certain workloads. Normally a server")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# restart is needed in order to lower the fragmentation, or at least to flush")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# away all the data and create it again. However thanks to this feature")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# implemented by Oran Agra for Redis 4.0 this process can happen at runtime")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# in an "hot" way, while the server is running.')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Basically when the fragmentation is over a certain level (see the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# configuration options below) Redis will start to create new copies of the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# values in contiguous memory regions by exploiting certain specific Jemalloc")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# features (in order to understand if an allocation is causing fragmentation")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# and to allocate it in a better place), and at the same time, will release the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# old copies of the data. This process, repeated incrementally for all the keys")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# will cause the fragmentation to drop back to normal values.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Important things to understand:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 1. This feature is disabled by default, and only works if you compiled Redis")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    to use the copy of Jemalloc we ship with the source code of Redis.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    This is the default with Linux builds.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 2. You never need to enable this feature if you don't have fragmentation")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#    issues.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# 3. Once you experience fragmentation, you can enable this feature when")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('#    needed with the command "CONFIG SET activedefrag yes".')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# The configuration parameters are able to fine tune the behavior of the")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# defragmentation process. If you are not sure about what they mean it is")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# a good idea to leave the defaults untouched.")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Enabled active defragmentation")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# activedefrag yes")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Minimum amount of fragmentation waste to start active defrag")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# active-defrag-ignore-bytes 100mb")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Minimum percentage of fragmentation to start active defrag")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# active-defrag-threshold-lower 10")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Maximum percentage of fragmentation at which we use maximum effort")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# active-defrag-threshold-upper 100")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Minimal effort for defrag in CPU percentage")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# active-defrag-cycle-min 5")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Maximal effort for defrag in CPU percentage")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# active-defrag-cycle-max 75")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Maximum number of set/hash/zset/list fields that will be processed from")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the main dictionary scan")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# active-defrag-max-scan-fields 1000")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# It is possible to pin different threads and processes of Redis to specific")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# CPUs in your system, in order to maximize the performances of the server.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# This is useful both in order to pin different Redis threads in different")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# CPUs, but also in order to make sure that multiple Redis instances running")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in the same host will be pinned to different CPUs.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# Normally you can do this using the "taskset" command, however it is also')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# possible to this via Redis configuration directly, both in Linux and FreeBSD.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# You can pin the server/IO threads, bio threads, aof rewrite child process, and")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the bgsave child process. The syntax to specify the cpu list is the same as")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the taskset command:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set redis server/io threads to cpu affinity 0,2,4,6:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# server_cpulist 0-7:2")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set bio threads to cpu affinity 1,3:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bio_cpulist 1,3")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set aof rewrite child process to cpu affinity 8,9,10,11:")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# aof_rewrite_cpulist 8-11")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Set bgsave child process to cpu affinity 1,10,11")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# bgsave_cpulist 1,10-11")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# In some cases redis will emit warnings and even refuse to start if it detects")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# that the system is in bad state, it is possible to suppress these warnings")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# by setting the following config which takes a space delimited list of warnings")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# to suppress")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# ignore-warnings ARM64-COW-BUG")]),e._v("\n")])])]),s("h2",{attrs:{id:"docker-compose-yml"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose-yml"}},[e._v("#")]),e._v(" docker-compose.yml")]),e._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("version")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'3.3'")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("services")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n      "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("redis")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("image")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("6.2.5\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("restart")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" always\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("hostname")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" redis\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("container_name")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" redis\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# root权限")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("privileged")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[e._v("true")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("ports")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" 6379"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("6379")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("environment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n          "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("TZ")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" Asia/Shanghai\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("volumes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" ./data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("/data\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" ./conf/redis.conf"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("/etc/redis/redis.conf\n          "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("-")]),e._v(" ./logs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v("/logs\n        "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[e._v("command")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"redis-server"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"/etc/redis/redis.conf"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);